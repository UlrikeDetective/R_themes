---
title: "GPS Mapping with R"
format: html
editor: visual
---

## GPS Mapping with R

```{r}
#install.packages("gpx")
#install.packages("ggspatial")
#install.packages("patchwork")
library(gpx)
library(sf)
library(dplyr)
library(ggplot2)
library(ggspatial)
library(patchwork)
```

## **Loading the data**

Let’s get started. With Python, we needed to parse the raw `gpx` data, which is in an XML format, to a CSV formatted file, which could then be imported into a `pandas` data frame, and then turned that into a `geopandas` data frame. I used `beautifulsoup` to do so. R, fortunately, has a `gpx` library that allows us to go straight from `gpx` into a data frame. Let’s see what that looks like. The `str()` command will let us know what’s inside.

```{r}
trek_data <- read_gpx("/Users/ulrike_imac_air/projects/Trial_and_error/R_code/route_2025-03-20_5.36pm.gpx")
str(trek_data)
```

The result is not a data frame, but a list of lists. The second one, called tracks, is the only one with observations, so we can start with that. Don’t forget that R does not zero-index lists, so we use `2` not `1`, and extract it with double square brackets.

```{r}
trek_tracks <- trek_data[[2]]
str(trek_tracks)
```

This gets us closer, now we have list of one. Let’s pull that out and display the first two rows.

```{r}
trek <- trek_tracks[[1]]
trek[1:2,]
```

Note the comma, which is very important. If only one value is supplied, it chooses columns instead of rows.

```{r}
head(trek[1:2], 2)
```

And the final frame looks like:

```{r}
str(trek)
```

## **Importing a collection of treks**

Now that I know “where” the information is, I can go ahead and import a series of files and combine them into a single data frame. As I did with Python, I will assign a unique identifier to each trek, and then combine them. The R equiva

lent of `df.append` in `pandas` is the aptly-named `bind_rows()` from the `dplyr` library.

```{r}
files <- list.files(path = "/Users/ulrike_imac_air/projects/Trial_and_error/R_code/Basel", 
                    pattern = "\\.gpx$",
                    full.names = TRUE)
data_list <- list()
i <- 1
for (file in files) {
  data <- read_gpx(file)[[2]][[1]]
  data$id = i
  i <- i + 1
  data_list[[file]] <- data
}
tracks_df <- dplyr::bind_rows(data_list)
str(tracks_df)
```

Note the use of `$` to access the columns. An alternate syntax, `data['id']` is available for column names with spaces. This is like `pandas` use of the `.` operator.

## **Data frame to geo-data**

In Python, we turned this into a geo-enabled data frame with:

\`\`\`{python}\
trek_gdf = gpd.GeoDataFrame(\
trek_df,\
geometry=gpd.points_from_xy(x=trek_df.Lon, y=trek_df.Lat)\
).set_crs(4269)\
trek_gdf.info()\
\`\`\`

R uses the `sf::st_as_sf()` for this purpose, with much less verbose syntax.

```{r}
treks <- tracks_df |> 
  st_as_sf(coords = c("Longitude","Latitude"),
           crs = 4326)
```

```{r}
str(treks)
```

As you can see, we now have a `geometry` column and the `Time` column was assigned the appropriate type, which we had to do as an additional step in Python. I’ll grab the first trek, then plot it with `ggplot`. Using `ggplot` entails adding elements one by one.

```{r}
trek <- treks[treks$id == 6,]
```

```{r}
# install.packages("prettymapr")

```

```{r}
library(ggplot2)
library(ggspatial)

ggplot(data = trek) +
  ggspatial::annotation_map_tile(      
    type = "osm",
    cachedir = "maps/",
    zoomin = -1) +
  geom_sf(aes(color = Elevation)) +
  scale_color_viridis_c() +
  theme_void() +
  labs(
    title = paste("Elevation Profile: Park Ridge", as.Date(trek[6,]$Time)),
    caption = "Tiles © OpenStreetMap (ODBL license)"
  )
```

In this case, we pass the data frame (actually an `sf` object) to `ggplot`, then layer on the basemap and the actual points using `geom_sf`, passing it the column we want to color using the `aes()` funtion. “aes” is short for aesthetics, and it is where you specify columns to be used for that element. The details of this vary depending on the geometry. `theme_void()` removes axis ticks, and the rest should be self-explanatory.

We still must change the coordinate system to get appropriate distances. In R, this is

```{r}
trek_proj <- trek |> st_transform(crs = 32113)
```

In Python, we did

```{{python}}
trek_proj = trek_gdf.to_crs(32111)
```

While the syntax looks similar, Python is accessing a method of the `trek` object, while R is simply passing the output of one function to another.

## **Elevations**

I won’t move beyond points until the next article, but in the first Python one I did calculate the distance, so to be fair I will do so here. I’ll explain the code later, but it is a good example of piping in R.

```{r}
distance <- trek |> 
  st_transform(crs = 32113) |> 
  dplyr::summarise(do_union = F) |> 
  st_cast("LINESTRING") |> 
  st_length()
print(paste("Total distance", round(distance/1000, digits = 1), "kilometers"))
```

Let’s see the other basic information. I will put it in a data frame for a nice printout.

```{r}
data.frame(
  "Elevation" = c("Maximum",
             "Minimum",
             "Average",
             "Initial",
             "Final"),
  "Meters" = c(max(trek$Elevation),
               min(trek$Elevation),
               round(mean(trek$Elevation)),
               trek[1,]$Elevation,
               trek[length(trek),]$Elevation)
)
```

The `c()` function is used to create a vector (not a list), so I specify each column name and assign it a vector with data, ensuring that each vector has the same length, of course. Note how I access the last row of `trek`. There are multiple ways of doing this in R, but sadly negative indexing is not one. This is the most efficient. I will say that I miss Python’s f-string, especially with literals (`f""" """`).

Now we can use `ggplot` for a line chart of the elevation.

```{r}
ggplot(trek, aes(x = Time, y = Elevation)) +
  geom_line() +
  ggtitle(paste("Elevation Profile for Park Ridge Walk on", as.Date(trek[1,]$Time)))
```

And here are the smoothed profiles using two different methods, and display them side by side with the `patchwork` library.

```         
```

```{r}
library(patchwork)
rgam_plot <- ggplot(trek, aes(x = Time, y = Elevation)) +
  geom_line() +
  geom_smooth(method = "gam") +
  ggtitle(paste("NJ (gam smoothing)", as.Date(trek[1,]$Time)))

loess_plot <- ggplot(trek, aes(x = Time, y = Elevation)) +
  geom_line() +
  geom_smooth(method = "loess") +
  ggtitle(paste("NJ (loess smoothing)", as.Date(trek[1,]$Time)))

rgam_plot | loess_plot
```

`ggplot2`’s approach of adding layers makes code clear and easy to write, and does not have the odd `fig, ax` mechanism which can be confusing.

## Basel

```{r}
files <- list.files(path = "/Users/ulrike_imac_air/projects/Trial_and_error/R_code/Basel", 
                    pattern = "\\.gpx$",
                    full.names = TRUE)
data_list <- list()
i <- 1
for (file in files) {
  data <- read_gpx(file)[[2]][[1]]
  data$id = i
  i <- i + 1
  data_list[[file]] <- data
}
tracks_basel <- dplyr::bind_rows(data_list)
str(tracks_basel)
```

```{r}
treks_basel <- tracks_basel |> 
  st_as_sf(coords = c("Longitude","Latitude"),
           crs = 4326)

str(treks_basel)
```

```{r}
library(ggplot2)
library(ggspatial)

ggplot(data = treks_basel) +
  ggspatial::annotation_map_tile(      
    type = "osm",
    cachedir = "maps/",
    zoomin = -1) +
  geom_sf(aes(color = Elevation)) +
  scale_color_viridis_c() +
  theme_void() +
  labs(
    title = paste("Elevation Profile: Basel", as.Date(treks_basel$Time)),
    caption = "Tiles © OpenStreetMap (ODBL license)"
  )
```

```{r}
trek_proj_basel <- treks_basel |> st_transform(crs = 32113)
```

```{r}
distance <- treks_basel |> 
  st_transform(crs = 32113) |> 
  dplyr::summarise(do_union = F) |> 
  st_cast("LINESTRING") |> 
  st_length()
print(paste("Total distance", round(distance/1000, digits = 1), "kilometers"))
```

```{r}
data.frame(
  "Elevation" = c("Maximum",
             "Minimum",
             "Average",
             "Initial",
             "Final"),
  "Meters" = c(max(treks_basel$Elevation),
               min(treks_basel$Elevation),
               round(mean(treks_basel$Elevation)),
               treks_basel[1,]$Elevation,
               trek[length(treks_basel),]$Elevation)
)
```

```{r}
ggplot(treks_basel, aes(x = Time, y = Elevation)) +
  geom_line() +
  ggtitle(paste("Elevation Profile Basel walks", as.Date(trek[1,]$Time)))
```

```{r}
treks_basel <- treks_basel %>%
  mutate(
    Date = as.Date(Time),
    TimeOfDay = hms::as_hms(Time)   # keeps only HH:MM:SS
  )

ggplot(treks_basel, aes(x = TimeOfDay, y = Elevation)) +
  geom_line() +
  facet_wrap(~ Date) +
  labs(
    title = "Elevation Profile Basel walks",
    x = "Time of day",
    y = "Elevation (m)"
  ) +
  theme_minimal()


```

```{r}
library(patchwork)
rgam_plot <- ggplot(treks_basel, aes(x = Time, y = Elevation)) +
  geom_line() +
  geom_smooth(method = "gam") +
  ggtitle(paste("NJ (gam smoothing)", as.Date(treks_basel[1,]$Time)))

loess_plot <- ggplot(treks_basel, aes(x = Time, y = Elevation)) +
  geom_line() +
  geom_smooth(method = "loess") +
  ggtitle(paste("NJ (loess smoothing)", as.Date(treks_basel[1,]$Time)))

rgam_plot | loess_plot
```

## Ibiza

```{r}
files <- list.files(path = "/Users/ulrike_imac_air/projects/Trial_and_error/R_code/Ibiza", 
                    pattern = "\\.gpx$",
                    full.names = TRUE)
data_list <- list()
i <- 1
for (file in files) {
  data <- read_gpx(file)[[2]][[1]]
  data$id = i
  i <- i + 1
  data_list[[file]] <- data
}
tracks_ibiza <- dplyr::bind_rows(data_list)
str(tracks_ibiza)
```

```{r}
treks_ibiza <- tracks_ibiza |> 
  st_as_sf(coords = c("Longitude","Latitude"),
           crs = 4326)

str(treks_ibiza)
```

```{r}
library(ggplot2)
library(ggspatial)

ggplot(data = treks_ibiza) +
  ggspatial::annotation_map_tile(      
    type = "osm",
    cachedir = "maps/",
    zoomin = -1) +
  geom_sf(aes(color = Elevation)) +
  scale_color_viridis_c() +
  theme_void() +
  labs(
    title = paste("Elevation Profile: Ibiza", as.Date(treks_ibiza$Time)),
    caption = "Tiles © OpenStreetMap (ODBL license)"
  )
```

```{r}
trek_proj_ibiza <- treks_ibiza |> st_transform(crs = 32113)

distance <- treks_ibiza |> 
  st_transform(crs = 32113) |> 
  dplyr::summarise(do_union = F) |> 
  st_cast("LINESTRING") |> 
  st_length()
print(paste("Total distance", round(distance/1000, digits = 1), "kilometers"))
```

```{r}
data.frame(
  "Elevation" = c("Maximum",
             "Minimum",
             "Average",
             "Initial",
             "Final"),
  "Meters" = c(max(treks_ibiza$Elevation),
               min(treks_ibiza$Elevation),
               round(mean(treks_ibiza$Elevation)),
               treks_ibiza[1,]$Elevation,
               trek[length(treks_ibiza),]$Elevation)
)
```

```{r}
ggplot(treks_ibiza, aes(x = Time, y = Elevation)) +
  geom_line() +
  ggtitle(paste("Elevation Profile ibiza walks", as.Date(trek[1,]$Time)))
```

```{r}
treks_ibiza <- treks_ibiza %>%
  mutate(
    Date = as.Date(Time),
    TimeOfDay = hms::as_hms(Time)   # keeps only HH:MM:SS
  )

ggplot(treks_ibiza, aes(x = TimeOfDay, y = Elevation)) +
  geom_line() +
  facet_wrap(~ Date) +
  labs(
    title = "Elevation Profile Ibiza walks",
    x = "Time of day",
    y = "Elevation (m)"
  ) +
  theme_minimal()
```
